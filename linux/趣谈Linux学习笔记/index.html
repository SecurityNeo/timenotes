<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>趣谈Linux内核 - TimeNotes</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">TimeNotes</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Home</a>
                            </li>
                            <li >
                                <a href="../../net/趣谈网络协议笔记/">趣谈网络协议</a>
                            </li>
                            <li class="active">
                                <a href="./">趣谈Linux内核</a>
                            </li>
                            <li >
                                <a href="../Linux性能优化/">Linux性能优化实战</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../../net/趣谈网络协议笔记/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../Linux性能优化/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#01">01 开篇介绍</a></li>
        <li class="main "><a href="#03">03 学习路径</a></li>
        <li class="main "><a href="#04-linux">04 认识 Linux</a></li>
            <li><a href="#_1">内核代码</a></li>
        <li class="main "><a href="#05-linux">05 快速上手 Linux 命令</a></li>
            <li><a href="#_2">用户名和密码</a></li>
            <li><a href="#_3">浏览文件</a></li>
            <li><a href="#_4">安装软件</a></li>
            <li><a href="#_5">开关机</a></li>
            <li><a href="#_6">一图总结之</a></li>
        <li class="main "><a href="#05">05 系统调用</a></li>
            <li><a href="#_7">一图总结</a></li>
        <li class="main "><a href="#06-x86">06 x86 体系架构</a></li>
        <li class="main "><a href="#07-linux">07 Linux 启动过程</a></li>
        <li class="main "><a href="#08">08 内核初始化</a></li>
        <li class="main "><a href="#09">09 系统调用</a></li>
        <li class="main "><a href="#10">10 进程</a></li>
        <li class="main "><a href="#11">11 线程</a></li>
        <li class="main "><a href="#12">12 进程数据结构</a></li>
        <li class="main "><a href="#13">13 进程数据结构（中）</a></li>
        <li class="main "><a href="#_8">加餐（一）学习攻略</a></li>
        <li class="main "><a href="#14">14 进程数据结构（下）</a></li>
        <li class="main "><a href="#15">15 调度（上）</a></li>
        <li class="main "><a href="#16">16 调度（中）</a></li>
        <li class="main "><a href="#17">17 调度（下）</a></li>
        <li class="main "><a href="#18">18 进程的创建</a></li>
        <li class="main "><a href="#19">19 线程的创建</a></li>
        <li class="main "><a href="#20">20 内存管理（上）：规划进程内存空间布局</a></li>
        <li class="main "><a href="#21">21 内存管理（下）</a></li>
        <li class="main "><a href="#22">22 进程空间管理</a></li>
        <li class="main "><a href="#23">23 物理内存管理（上）</a></li>
        <li class="main "><a href="#24">24 物理内存管理（下）</a></li>
        <li class="main "><a href="#25">25 用户态内存映射</a></li>
        <li class="main "><a href="#26">26 内核态内存映射</a></li>
        <li class="main "><a href="#27">27 文件系统</a></li>
        <li class="main "><a href="#28">28 硬盘文件系统</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<div class="toc">
<ul>
<li><a href="#01">01 开篇介绍</a></li>
<li><a href="#03">03 学习路径</a></li>
<li><a href="#04-linux">04 认识 Linux</a><ul>
<li><a href="#_1">内核代码</a></li>
</ul>
</li>
<li><a href="#05-linux">05 快速上手 Linux 命令</a><ul>
<li><a href="#_2">用户名和密码</a></li>
<li><a href="#_3">浏览文件</a></li>
<li><a href="#_4">安装软件</a></li>
<li><a href="#_5">开关机</a></li>
<li><a href="#_6">一图总结之</a></li>
</ul>
</li>
<li><a href="#05">05 系统调用</a><ul>
<li><a href="#_7">一图总结</a></li>
</ul>
</li>
<li><a href="#06-x86">06 x86 体系架构</a></li>
<li><a href="#07-linux">07 Linux 启动过程</a></li>
<li><a href="#08">08 内核初始化</a></li>
<li><a href="#09">09 系统调用</a></li>
<li><a href="#10">10 进程</a></li>
<li><a href="#11">11 线程</a></li>
<li><a href="#12">12 进程数据结构</a></li>
<li><a href="#13">13 进程数据结构（中）</a></li>
<li><a href="#_8">加餐（一）学习攻略</a></li>
<li><a href="#14">14 进程数据结构（下）</a></li>
<li><a href="#15">15 调度（上）</a></li>
<li><a href="#16">16 调度（中）</a></li>
<li><a href="#17">17 调度（下）</a></li>
<li><a href="#18">18 进程的创建</a></li>
<li><a href="#19">19 线程的创建</a></li>
<li><a href="#20">20 内存管理（上）：规划进程内存空间布局</a></li>
<li><a href="#21">21 内存管理（下）</a></li>
<li><a href="#22">22 进程空间管理</a></li>
<li><a href="#23">23 物理内存管理（上）</a></li>
<li><a href="#24">24 物理内存管理（下）</a></li>
<li><a href="#25">25 用户态内存映射</a></li>
<li><a href="#26">26 内核态内存映射</a></li>
<li><a href="#27">27 文件系统</a></li>
<li><a href="#28">28 硬盘文件系统</a></li>
</ul>
</div>
<h2 id="01">01 开篇介绍</h2>
<p>开篇词就是总结了接下来要学习的东西。总的来说，这门课有以下亮点：</p>
<ul>
<li>有深度（其中涉及到 Linux 内核源码解析）</li>
<li>有广度（从 Linux 基础，谈到内核，到虚拟化，到容器、集群、数据中心操作系统等）</li>
<li>有趣味（类比于一家公司，操作系统是这家公司的老板）</li>
<li>图文并茂</li>
</ul>
<p>开篇放出了一张 Linux 操作系统全景图（深入到代码），如下：</p>
<p><img alt="alllinux" src="../images/alllinux.jpg" /></p>
<p>这张图展示了进程、文件、文件系统、硬盘之间的一个关系（Linux的哲学之一就是一切皆文件），这里面涉及到内核代码结构，其实就是一个个的数据结构拼接起来，想象一下，操作系统那么多组件，怎么样很好地管理这些组件，就是把他们定义成一个个的数据结构，然后有关系的就连接起来。</p>
<h2 id="03">03 学习路径</h2>
<p>一图胜千言</p>
<p><img alt="" src="../images/linuxpath.jpeg" /></p>
<h2 id="04-linux">04 认识 Linux</h2>
<p>从电脑组装说起。一台电脑硬件上来说至少应该包括以下组件，才能满足我们个人的使用需求。</p>
<p><img alt="" src="../images/hw.png" /></p>
<p>光有这些硬件设备也玩不转一台电脑，必须要有一个类似于大脑的东西来指挥这些硬件才行，这个大脑就是操作系统。</p>
<p>操作系统要管理不同的硬件设备，就需要有不同的模块组件，就像一个组织需要设定几个不同的负责人一样。从功能和管理对象上说，可以分为以下几大类（操作系统体系结构图）：</p>
<p><img alt="" src="../images/linuxstruct.jpg" /></p>
<p>上面这幅图关注点在于内核态，对于完整的操作系统，还应该包括用户态，以及用户态和内核态的交互模块，下面这幅图包含了这一切，而且还包括了硬件部分，非常完整：</p>
<p><img alt="" src="../images/linuxmodule.png" /></p>
<hr />
<h3 id="_1">内核代码</h3>
<p><strong>如何找 Linux 内核代码？</strong></p>
<p>Linux 内核源码链接：</p>
<p>https://www.kernel.org/</p>
<p><em>在里面找到 <code>kernel/git/torvalds/linux.git</code> 即可下载</em></p>
<p>推荐一个 <strong>在线阅读源码</strong> 的网站（非常赞）：</p>
<p>https://elixir.bootlin.com/linux/latest/source</p>
<p><strong>内核代码结构如何体现出上面的几大子系统的？</strong></p>
<p>以 Linux 3.0 为例看看它的代码结构：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>arch</td>
<td>包含和硬件体系结构相关的代码，每种平台占一个相应的目录，如 i386、 ARM、PowerPC、MIPS 等。</td>
</tr>
<tr>
<td>block</td>
<td>块设备驱动程序 I/O 模块。</td>
</tr>
<tr>
<td>crypto</td>
<td>常用加密和散列算法（如 AES、SHA 等），还有一些压缩和 CRC 校 验算法。</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序，每个不同的驱动占用一个子目录，如 char、block、net、 mtd、i2c 等。</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>vfs 和 支持的各种文件系统，如 EXT、FAT、NTFS、JFFS2 等。</td>
</tr>
<tr>
<td>include</td>
<td>内核 头文件，与系统相关的头文件被放置在 include/linux 子目录下</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化代码</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信的代码</td>
</tr>
<tr>
<td>kernel</td>
<td>内核的最核心部分，包括进程调度、定时器等，而和平台相关的一 部分代码放在 arch/*/kernel 目录下</td>
</tr>
<tr>
<td>lib</td>
<td>库文件代码，通用内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统代码，和平台相关的一部分代码放在 arch/*/mm 目录下</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统相关代码，实现了各种常见的网络协议</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本文件</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块， 主要包含 SELinux 模块。</td>
</tr>
<tr>
<td>sound</td>
<td>音频子系统， ALSA、OSS 音频设备的驱动核心代码和常用设备驱动。</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）， 实现了用于打包和压缩的 cpio 等</td>
</tr>
<tr>
<td>tools</td>
<td>在 Linux 开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody>
</table>
<h2 id="05-linux">05 快速上手 Linux 命令</h2>
<h3 id="_2">用户名和密码</h3>
<ul>
<li>配置 root 密码：<code>passwd</code> 或 <code>passwd root</code> （<code>passwd &lt;user&gt;</code>）</li>
<li>创建一个新的用户：<code>useradd jay</code></li>
<li>创建一个新的用户并加到某个组里：<code>useradd jay -g &lt;gid&gt;</code></li>
<li><code>/etc/passwd</code> 和 <code>/etc/group</code> 中能够看到用户密码和用户组的信息</li>
</ul>
<h3 id="_3">浏览文件</h3>
<pre><code class="sh">ls -l
drwxr-xr-x 6 root root    4096 Oct 20  2017 apt
-rw-r--r-- 1 root root     211 Oct 20  2017 hosts
</code></pre>

<ul>
<li>第一个字段中的第一个字符 <code>-</code> 表示普通文件，<code>d</code> 表示目录文件，<code>l</code> 表示连接文件</li>
<li>接着后面 9 个字符表示模式（权限位），前面 3 个是所属用户的读写执行权限，中间 3 个是用户所属组的，后面 3 个是其他用户的。改变权限使用 <code>chmod 711 &lt;file&gt;</code> </li>
<li>第二个字段是硬链接数目</li>
<li>第三个字段是所属用户</li>
<li>第四个字段是所属用户组</li>
<li>第五个字段是文件大小</li>
<li>第六个字段是文件被修改的日期</li>
<li>最后是文件名</li>
</ul>
<p><code>chmod</code> 改变文件权限，<code>chown</code> 改变所属用户，<code>chgrp</code> 改变所属组。</p>
<pre><code class="sh"># 将文件 file.txt 的拥有者改为 root，这个命令需要有超级用户权限才能执行，所以我们在命令之前加上sudo
sudo chown root file.txt 
</code></pre>

<pre><code class="sh"># 改变文件的拥有组为root组
sudo chgrp root file.txt

# 将文件的所属组由 root 改为 tim
chgrp -v tim file.txt
</code></pre>

<h3 id="_4">安装软件</h3>
<p>相对于 Windows 的 <code>exe</code>、<code>zip</code> 等包，Linux 常用有 <code>rpm</code>（Centos 系）、<code>deb</code>（Ubuntu 系） 和 <code>tar.gz</code> 等包。</p>
<ul>
<li><code>rpm</code> 和 <code>deb</code></li>
</ul>
<pre><code class="sh"># centos rpm
rpm -i jdk-XXX_linux-x64_bin.rpm

# ubuntu deb
dpkg -i jdk-xxx_linux-x64_bin.deb

# 查看安装软件列表
rpm -qa
dpkg -l

# 翻页
rpm -qa | more
rpm -qa | less

# 加搜索
rpm -qa | grep jdk
dpkg -l | grep jdk

# 删除
rpm -e 
dpkg -r

</code></pre>

<ul>
<li>Linux 软件管家：<code>yum</code> 和 <code>apt-get</code></li>
</ul>
<pre><code class="sh"># 搜索软件
yum search jdk
apt-cache search jdk

# 安装
yum install java-11-openjdk.x86_64
apt-get install openjdk-9-jdk
</code></pre>

<ul>
<li>配置软件源：国内常用是 <code>阿里源</code> 和 <code>163源</code>。（用到时搜索即可）</li>
</ul>
<p>centos：<code>/etc/yum.repos.d/CentOS-Base.repo</code></p>
<p>ubuntu: <code>/etc/apt/sources.list</code></p>
<ul>
<li>包下载和压缩解压缩</li>
</ul>
<pre><code class="sh"># 下载
wget

# 压缩解压缩
yum install zip.x86_64 unzip.x86_64
apt-get install zip unzip

unzip &lt;xx.zip&gt;
tar zxvf jdk-XXX_linux-x64_bin.tar.gz
</code></pre>

<ul>
<li>运行程序</li>
</ul>
<pre><code class="sh"># 01 直接运行
&lt;command&gt; 或者 &lt;./command&gt;

# 02 后台运行
nohup &lt;command&gt; &gt;out.file 2&gt;&amp;1 &amp;

# 后台进程关闭
ps -ef |grep 关键字  |awk '{print $2}'|xargs kill -9

# 03 以服务的方式运行 /lib/systemd/system
# 比如 mysql
apt-get install mysql-server # 安装
systemctl start mysql # 启动
systemctl enable mysql # 设置开机启动

# centos 中 MySQL 是 MariaDB。/usr/lib/systemd/system/
</code></pre>

<h3 id="_5">开关机</h3>
<pre><code class="sh"># 关机
shutdown -h now
poweroff

# 重启
reboot
</code></pre>

<h3 id="_6">一图总结之</h3>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/88/e5/8855bb645d8ecc35c80aa89cde5d16e5.jpg" /></p>
<h2 id="05">05 系统调用</h2>
<p><strong>进程相关系统调用：</strong> </p>
<ul>
<li>fork：创建子进程，返回两个值，如果是 0，表示子进程，如果 &gt;0 表示父进程，值是子进程的 ID。</li>
<li>execve：创建出的子进程执行的系统调用（有一套函数集）。</li>
<li>waitpid：父进程监听子进程的执行情况。</li>
</ul>
<p>通过如下方式查询更加详细的信息:</p>
<pre><code class="sh">$ps -o pid,pgid,ppid,sid,tty,comm
</code></pre>

<p>(tty表示控制终端）</p>
<p>进程地址空间：</p>
<p><img alt="" src="../images/process.png" /></p>
<p><strong>进程内存空间分配系统调用：</strong></p>
<ul>
<li>brk：当分配内存量小的时候（具体是 128K）使用；</li>
<li>mmap：当分配内存量大于 128K 时使用，这么做的目的是避免 <strong>内存碎片</strong> 的问题。参考<a href="https://blog.csdn.net/yusiguyuan/article/details/39496057">这里</a></li>
</ul>
<p><strong>异常与信号处理相关系统调用：</strong></p>
<ul>
<li>kill：用户进程发送一个退出信号给另一个进程</li>
<li>sigaction：信号处理函数（无视(ignore)信号、默认(default)操作、自定义操作）</li>
</ul>
<p><code>$man 7 signal</code> 查阅更多的信号。一些常用的信号：</p>
<ul>
<li><code>SIGINT</code>   当键盘按下 <code>CTRL+C</code> 从 shell 中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。</li>
<li><code>SIGQUIT</code>  当键盘按下 <code>CTRL+\</code> 从 shell 中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。</li>
<li><code>SIGTSTP</code>  当键盘按下 <code>CTRL+Z</code> 从 shell 中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。</li>
<li><code>SIGCONT</code>  用于通知暂停的进程继续。</li>
<li><code>SIGALRM</code>  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。</li>
</ul>
<p><strong>进程间通信系统调用：</strong></p>
<ul>
<li>消息队列：msgget（创建）、msgsnd（发送）、msgrcv（接收）</li>
<li>共享内存（通信量大）：shmget（创建）、shmat（映射共享内存）</li>
<li>信号量（资源访问竞争）：sem_wait（占用资源）、sem_post（释放资源）</li>
<li>管道（无名管道和命名管道）</li>
<li>Socket</li>
<li>参考<a href="https://songlee24.github.io/2015/04/21/linux-IPC/">这里</a></li>
</ul>
<p><strong>C 函数库（glibc）和系统调用的关系：</strong></p>
<p>C 函数库是对相关系统调用函数的进一步封装，目的是以一种更友好的方式供上层用户的调用。系统调用更像是组成一个汉字的 <strong>笔画</strong> ，而库函数则像 <strong>偏旁部首</strong> 。比如 glibc 中的 printf 函数就会调用 <code>sys_open</code>、<code>sys_mmap</code>、<code>sys_write</code>、<code>sys_close</code> 等系统调用函数。malloc 函数也会进一步调用到 <code>sys_brk</code> 等函数。</p>
<p><strong>Tips：</strong></p>
<p><code>$man 2 syscalls</code> 可以查看所有的系统调用，<code>$man 2 read</code> 查看系统调用 read 的详细说明。</p>
<h3 id="_7">一图总结</h3>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/ff/f0/ffb6847b94cb0fd086095ac263ac4ff0.jpg" /></p>
<h2 id="06-x86">06 x86 体系架构</h2>
<p>硬件图结合计算机的逻辑图：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/fa/9b/fa6c2b6166d02ac37637d7da4e4b579b.jpeg" /></p>
<p>CPU 和 内存如何配合工作：</p>
<p>CPU 包括：</p>
<ul>
<li>运算单元：如加减乘除</li>
<li>数据单元：CPU 内部的缓存和寄存器组</li>
<li>控制单元：指令获取、控制</li>
<li>指令指针寄存器：执行下一条指令在内存中的地址</li>
<li>指令寄存器</li>
</ul>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/3a/23/3afda18fc38e7e53604e9ebf9cb42023.jpeg" /></p>
<p>x86 CPU 组件放大图：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/2d/1c/2dc8237e996e699a0361a6b5ffd4871c.jpeg" /></p>
<p>运算单元：</p>
<ul>
<li>通用寄存器</li>
</ul>
<p>控制单元：</p>
<ul>
<li>IP：指令指针寄存器</li>
<li>CS： 代码寄存器</li>
<li>DS：数据寄存器</li>
<li>SS：栈寄存器</li>
</ul>
<p>一图总结之：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/e2/76/e2e92f2239fe9b4c024d300046536d76.jpeg" /></p>
<h2 id="07-linux">07 Linux 启动过程</h2>
<p>1 打开电源，从主板上的 BIOS 读取其中存储的程序，这个程序知道主板连接哪些硬件（硬盘、网络接口、键盘、串口、并口），BIOS 会检查以哪种方式启动（软盘、光盘、硬盘）。（BIOS 存储在 ROM 只读区）</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/5f/fc/5f364ef5c9d1a3b1d9bb7153bd166bfc.jpeg" /></p>
<p>2 读取启动盘中的前 512 个字节，也就是 MBR （主引导扇区）</p>
<p>3 MBR 会从设备的某一个分区来转载 <strong>引导加载程序</strong> （BootLoader） ，BootLoader 含有 OS 相关的信息，比如 OS 内核，OS 内核所在的位置等。常用的 BootLoader 程序有 <strong>GRUB2</strong> 和 <strong>LILO</strong> 。</p>
<p>可以通过 <code>grub2-mkconfig -o /boot/grub2/grub.cfg</code> 来配置系统启动的选项。</p>
<p>4 BootLoader 接着会加载内核程序</p>
<p>具体地，它会安装 <code>boot.img</code> 、<code>core.img</code> 等镜像程序。其中 <code>kernel.img</code> 就是存放的 OS 内核程序。一般会有多个程序（多操作系统），我们选择其中一个。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/2b/6a/2b8573bbbf31fc0cb0420e32d07b196a.jpeg" /></p>
<p>5 假如选择 Linux内核，内核会预留一部分自己的内存空间，然后通过驱动程序检测哪些计算机硬件可用，然后会启动一个 <code>init</code> 进程，它是 Linux 内核中的 1 号进程（Linux 没有 0 号进程），至此，便完成启动阶段做的事，接下来就交给 <code>init</code> 进程来管理。</p>
<p>6 <code>init</code> 进程会运行一系列的初始脚本（shell脚本）：</p>
<p>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……</p>
<p>至此，整个 OS 便准备好了，<code>init</code> 启动登录程序，输入用户名、密码便可自行玩耍了。</p>
<p><strong>附：</strong></p>
<p>grub2 命令的使用手册见：</p>
<p><a href="http://www.cnblogs.com/f-ck-need-u/p/7094693.html">http://www.cnblogs.com/f-ck-need-u/p/7094693.html</a></p>
<h2 id="08">08 内核初始化</h2>
<p>从源码上来讲，内核初始化从 函数 <code>start_kernel</code> 开始的，相当于内核的 <code>main</code> 函数，在文件 <code>init/main.c</code> 中。它总的要进行几件事：</p>
<ul>
<li>任务初始化</li>
<li>中断初始化</li>
<li>内存管理初始化</li>
<li>调度器初始化</li>
<li>其他（如进程线程）初始化</li>
</ul>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/cd/01/cdfc33db2fe1e07b6acf8faa3959cb01.jpeg" /></p>
<p><code>init_task</code> 产生 0 号进程，这是唯一一个没有通过 <code>fork</code> 或者其他 <code>kernel_thread</code> 产生的进程，是进程列表的第一个。</p>
<p><code>rest_init</code> 会产生两个进程，一号进程和二号进程来对用户态和内核进行初始化。</p>
<p>CPU 的分层权限限制，导致用户态和内核态的访问需要采用系统调用的手段：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/2b/42/2b53b470673cde8f9d8e2573f7d07242.jpg" /></p>
<p>系统调用总的一个过程基本上是：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/b1/99/b16beba7a40011cab8e54f938fefeb99.jpg" /></p>
<h2 id="09">09 系统调用</h2>
<p>用户态访问内核：</p>
<ul>
<li>系统调用</li>
<li>C 函数库 glibc（最终也是调用系统调用函数）</li>
</ul>
<p>在 glibc 源代码中，有个文件 <code>syscallls.list</code>，里面列着所有 glibc 的函数对应的系统调用。</p>
<pre><code class="C"># File name Caller  Syscall name    Args    Strong name Weak names
open        -   open        Ci:siv  __libc_open __open open
</code></pre>

<p>Glibc 还有一个文件 <code>syscall-tmplate.S</code> ，使用 宏，定义了系统调用的调用方式：</p>
<pre><code class="C">T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
    ret
T_PSEUDO_END (SYSCALL_SYMBOL)

#define T_PSEUDO(SYMBOL, NAME, N)       PSEUDO (SYMBOL, NAME, N)
</code></pre>

<p>这里有一个 宏 <code>PSEUDO</code>，对于任何一个系统调用，都会调用到这个 宏：</p>
<pre><code class="C">#define PSEUDO(name, syscall_name, args)                      \
  .text;                                      \
  ENTRY (name)                                    \
    DO_CALL (syscall_name, args);                         \
    cmpl $-4095, %eax;                               \
    jae SYSCALL_ERROR_LABEL
</code></pre>

<p>32 位系统调用过程和 64 位还有些许不同，我们直接看 64 位的：</p>
<p>接着，开始陷入内核，OS 会将系统调用名称转换为系统调用号，放到寄存器 rax 中，然后执行 <code>syscall</code>，然后通过一种特殊模块寄存器（MSR）来完成系统调用的功能，它会将系统调用相关的指令压入内核：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/86/a5/868db3f559ad08659ddc74db07a9a0a5.jpg" /></p>
<p>然后通过一个 <strong>系统调用表</strong> 找到相应的函数，进行执行。</p>
<p>系统调用表存放着所有的系统调用函数，对于 64位的系统，是定义在文件 <code>arch/x86/entry/syscalls/syscall_64.tbl</code> 中的（比如 <code>open</code> 是这样定义的）:</p>
<pre><code>2   common  open            sys_open
</code></pre>

<p>通过寄存器 rax 中的系统调用号，就可以找到系统调用表中对应的系统调用函数，从而执行真正的内核函数，比如 <code>open</code> 对应内核函数为 <code>sys_open</code>。</p>
<h2 id="10">10 进程</h2>
<p>安装开发套件：(centos 7)</p>
<pre><code class="sh">yum -y groupinstall &quot;Development Tools&quot;
</code></pre>

<p>程序文件具有 <strong>严格的格式</strong> ：ELF（Executeable and Linkable Format）</p>
<p>ELF 是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储的标准文件格式。</p>
<p>目标文件有三类（可通过 file 命令查看）：</p>
<ul>
<li>可重定位的目标文件（.o 文件）</li>
<li>可执行的目标文件（.exe 文件）</li>
<li>可被共享的目标文件（.so 动态库文件）</li>
</ul>
<p>从文本文件到二进制可执行文件的过程：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/85/de/85320245cd80ce61e69c8391958240de.jpeg" /></p>
<p>1、.o 文件时 ELF 的第一种文件类型，格式如下：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/e9/d6/e9c2b4c67f8784a8eec7392628ce6cd6.jpg" /></p>
<p>将 .o 归档为 .a 的静态库文件，使用命令 ar：</p>
<pre><code class="sh">ar cr libstaticprocess.a process.o
</code></pre>

<ul>
<li>.text：存放编译好的二进制可执行代码</li>
<li>.rodata：只读数据，例如字符串常量、const 的变量</li>
<li>.data：已经初始化好的全局变量</li>
<li>.bss：未初始化的全局变量</li>
<li>.symtab：符号表，记录的事函数和变量</li>
<li>.strtab：字符串表、字符串常量和变量名</li>
</ul>
<p>编译的时候使用静态链接库：</p>
<pre><code class="sh">gcc -o staticcreateprocess createprocess.o -L. -lstaticprocess
</code></pre>

<p>2、生成的二进制可执行文件为 ELF 的第二种格式。</p>
<p>静态链接库如果更新，那个多个引用的程序都要随之更新，效率低，因为出现动态链接库，可被多个程序共享。</p>
<p>3、动态链接库是 ELF 的第三种格式。共享对象文件。</p>
<pre><code class="sh">gcc -shared -fPIC -o libdynamicprocess.so process.o
</code></pre>

<pre><code class="sh">gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess
</code></pre>

<blockquote>
<p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
</blockquote>
<p>系统默认加载的路径是 /lib 和 /usr/lib，可以使用 <code>LD_LIBRARY_PATH</code> 来自定义动态库链接的路径。</p>
<pre><code class="sh">export LD_LIBRARY_PATH = .
</code></pre>

<p>进程调用 exec -&gt; load_elf_binary，最终将动态库加载的内存。</p>
<p>exec 函数：</p>
<ul>
<li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序； </li>
<li>不包含 p 的函数需要输入程序的全路径； </li>
<li>包含 v 的函数（execv, execvp,execve）以数组的形式接收参数； </li>
<li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数； 包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/46/f6/465b740b86ccc6ad3f8e38de25336bf6.jpg" /></p>
<p>进程树：</p>
<p>所有进程都是由父进程 fork 过来的，往前追溯，会找到祖宗进程，也就是系统启动的 init 进程。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/4d/16/4de740c10670a92bbaa58348e66b7b16.jpeg" /></p>
<p>有些系统中，比如 centos ，/sbin/init 会被链接到 systemd。</p>
<p>一图总结之：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/db/a9/dbd8785da6c3ce3fe1abb7bb5934b7a9.jpeg" /></p>
<p>Tips:</p>
<p>查看 ELF 文件的工具：</p>
<ul>
<li>readelf：分析 ELF 文件的信息</li>
<li>objdump：显示二进制文件信息</li>
<li>hexdump：查看文件的 16进制编码</li>
<li>nm：显示关于指定文件中符号的信息</li>
</ul>
<h2 id="11">11 线程</h2>
<p>多线程程序的编译依赖于 <code>libpthread.so</code></p>
<pre><code class="sh">gcc thread.c -lpthread
</code></pre>

<p>普通线程的创建和运行过程：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/e3/bd/e38c28b0972581d009ef16f1ebdee2bd.jpg" /></p>
<p>多线程可访问的数据：</p>
<ul>
<li>线程栈上的本地数据，比如函数执行过程中的局部变量。（<code>ulimit -a</code> 查看栈的大小）</li>
<li>整个进程里共享的全局数据，比如全局变量</li>
<li>线程的私有数据</li>
</ul>
<p>线程共享数据的保护问题：</p>
<ul>
<li>Mutex（互斥变量）</li>
<li>条件变量（一般和互斥锁配合使用）</li>
</ul>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/02/58/02a774d7c0f83bb69fec4662622d6d58.png" /></p>
<h2 id="12">12 进程数据结构</h2>
<p>在内核中，进程和线程都是由一个数据结构 <code>task_struct</code> 来统一管理。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/01/e8/016ae7fb63f8b3fd0ca072cb9964e3e8.jpeg" /></p>
<p>每个进程或线程定义一个这个结构，多个进程用链表连接起来。</p>
<p>其中，</p>
<p>任务 ID：</p>
<ul>
<li>pid：进程 id</li>
<li>tgid：多个线程中主线程对应的进程 ID</li>
<li>group_leader：多线程中主线程</li>
</ul>
<p>信号处理：</p>
<pre><code class="c">/* Signal handlers: */
struct signal_struct        *signal;
struct sighand_struct       *sighand;
sigset_t            blocked;
sigset_t            real_blocked;
sigset_t            saved_sigmask;
struct sigpending       pending;
unsigned long           sas_ss_sp;
size_t              sas_ss_size;
unsigned int            sas_ss_flags;
</code></pre>

<p>包括，</p>
<ul>
<li>blocked：阻塞暂不处理</li>
<li>pending：尚等待处理</li>
<li>sighand：正在被信号处理函数处理</li>
</ul>
<p>任务状态：</p>
<p>值定义在 <code>include/linux/sched.h</code> 中，</p>
<pre><code class="c">/* Used in tsk-&gt;state: */
#define TASK_RUNNING                    0
#define TASK_INTERRUPTIBLE              1
#define TASK_UNINTERRUPTIBLE            2
#define __TASK_STOPPED                  4
#define __TASK_TRACED                   8
/* Used in tsk-&gt;exit_state: */
#define EXIT_DEAD                       16
#define EXIT_ZOMBIE                     32
#define EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)
/* Used in tsk-&gt;state again: */
#define TASK_DEAD                       64
#define TASK_WAKEKILL                   128
#define TASK_WAKING                     256
#define TASK_PARKED                     512
#define TASK_NOLOAD                     1024
#define TASK_NEW                        2048
#define TASK_STATE_MAX                  4096
</code></pre>

<p>所有定义的状态如下图所示：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/e2/88/e2fa348c67ce41ef730048ff9ca4c988.jpeg" /></p>
<p>其中，</p>
<ul>
<li>TASK_RUNNING：表示进程在时刻准备运行（并不是正在运行，当获得 CPU 时间片的时候进入运行）</li>
<li>TASK_INTERRUPTIBLE：可中断的睡眠状态（浅睡眠），当信号来的时候，进程可被唤醒</li>
<li>TASK_UNINTERRUPTIBLE：不可中断的睡眠状态（深睡眠），不可被信号唤醒，只能死等 I/O 操作完成，kill 也不行</li>
<li>TASK_KILLABLE：可以终止的睡眠状态，上面的改良，可以响应致命信号</li>
<li>TASK_WAKEKILL：在接收致命信号时唤醒进程</li>
<li>TASK_STOPPED：进程收到 SIGSTOP、SIGINT、SIGTSTP 或者 SIGTTOU 后进入的状态</li>
<li>TASK_TRACED：进程被 debugger 等进程监视，进程执行被调试程序所停止</li>
<li>EXIT_ZOMBIE：进程结束首先进入的状态，如果父进程没有调用 waitpid() 函数的话，就成为 僵尸进程</li>
<li>EXIT_DEAD 进程的最终状态</li>
</ul>
<h2 id="13">13 进程数据结构（中）</h2>
<p>进程运行过程中一些统计量，可以更好地了解进程的工作情况：</p>
<pre><code class="C">u64             utime;// 用户态消耗的 CPU 时间
u64             stime;// 内核态消耗的 CPU 时间
unsigned long           nvcsw;// 自愿 (voluntary) 上下文切换计数
unsigned long           nivcsw;// 非自愿 (involuntary) 上下文切换计数
u64             start_time;// 进程启动时间，不包含睡眠时间
u64             real_start_time;// 进程启动时间，包含睡眠时间
</code></pre>

<p>进程的亲缘关系：</p>
<pre><code class="C">struct task_struct __rcu *real_parent; /* real parent process */
struct task_struct __rcu *parent; /* recipient of SIGCHLD, wait4() reports */
struct list_head children;      /* list of my children */
struct list_head sibling;       /* linkage in my parent's children list */
</code></pre>

<ul>
<li>parent：指向其父进程</li>
<li>children：表示链表头部</li>
<li>sibling：表示兄弟链表</li>
</ul>
<p>整个关系如下图所示：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/92/04/92711107d8dcdf2c19e8fe4ee3965304.jpeg" /></p>
<p>进程权限控制：</p>
<pre><code class="C">/* Objective and real subjective task credentials (COW): */
const struct cred __rcu         *real_cred;
/* Effective (overridable) subjective task credentials (COW): */
const struct cred __rcu         *cred;
</code></pre>

<ul>
<li>real_cred：谁能操作这个进程</li>
<li>cred：这个进程能够操作谁</li>
</ul>
<p>内存管理：</p>
<p>每个进程有自己的独立虚拟内存空间，用 <code>mm_struct</code> 表示：</p>
<pre><code class="C">struct mm_struct                *mm;
struct mm_struct                *active_mm;
</code></pre>

<p>文件与文件系统：</p>
<p>每个进程有一个文件系统的数据结构，和一个打开文件的数据结构：</p>
<pre><code class="C">/* Filesystem information: */
struct fs_struct                *fs;
/* Open file information: */
struct files_struct             *files;
</code></pre>

<h2 id="_8">加餐（一）学习攻略</h2>
<p>三遍学习法+PPT笔记</p>
<p>第一遍学习：先读薄，不要在乎一城一池的得失，梳理主次矛盾，记录所有问题</p>
<p>第二遍学习：再读厚，把握主线，攻克各个问题（用 PPT 笔记法记录这个过程）</p>
<p>第三遍学习：再读薄，变成自己的东西，总体梳理知识点，可以用xmind思维导图，融汇贯通</p>
<h2 id="14">14 进程数据结构（下）</h2>
<p>用户态函数栈：</p>
<p>函数调用时的栈如下所示（32位）：从高地址到低地址，往下增长，上面是栈底，下面是栈顶。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/ae/2e/aec865abccf0308155f4138cc905972e.jpg" /></p>
<p>在 64位的环境，EBP 变成了 RBP，ESP 变成了 RSP。</p>
<p>内核态函数栈：</p>
<p>进程用户态和内核态的联系用到如下结构：</p>
<pre><code class="c">struct thread_info      thread_info;
void  *stack;
</code></pre>

<p>其中，stack 即维护内核函数栈。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/31/2d/31d15bcd2a053235b5590977d12ffa2d.jpeg" /></p>
<p>当用户态切换到内核态后，需要将用户态运行过程中的 CPU 上下文保存起来，其实是保存的 <code>pt_regs</code> 这个结构，</p>
<p>通过 <code>task_struct</code> 的 <code>stack</code> 指针，就可以找到内核栈：</p>
<pre><code class="c">static inline void *task_stack_page(const struct task_struct *task)
{
    return task-&gt;stack;
}
</code></pre>

<p>通过 <code>stack</code> 就能很方便找到 <code>pt_regs</code>：</p>
<pre><code class="c">/*
 * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.
 * This is necessary to guarantee that the entire &quot;struct pt_regs&quot;
 * is accessible even if the CPU haven't stored the SS/ESP registers
 * on the stack (interrupt gate does not save these registers
 * when switching to the same priv ring).
 * Therefore beware: accessing the ss/esp fields of the
 * &quot;struct pt_regs&quot; is possible, but they may contain the
 * completely wrong values.
 */
#define task_pt_regs(task) \
({                                  \
    unsigned long __ptr = (unsigned long)task_stack_page(task); \
    __ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;     \
    ((struct pt_regs *)__ptr) - 1;                  \
})
</code></pre>

<p>反过来，内核栈通过 <code>thread_info</code> 这个结构来找 <code>task_struct</code>，</p>
<pre><code class="c">struct thread_info {
    struct task_struct  *task;      /* main task structure */
    __u32           flags;      /* low level flags */
    __u32           status;     /* thread synchronous flags */
    __u32           cpu;        /* current CPU */
    mm_segment_t        addr_limit;
    unsigned int        sig_on_uaccess_error:1;
    unsigned int        uaccess_err:1;  /* uaccess failed */
};
</code></pre>

<p>其中 <code>struct task_struct *task;</code> 即是指向 <code>task_struct</code>，通常 <code>current_thread_info()-&gt;task</code> 来获取 <code>task_struct</code>。</p>
<p>一图总结：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/82/5c/82ba663aad4f6bd946d48424196e515c.jpeg" /></p>
<h2 id="15">15 调度（上）</h2>
<p>指的是进程数量远超过 CPU 的数目，需要进行 CPU 调度执行。</p>
<p>进程包括两种：</p>
<ul>
<li>实时进程</li>
<li>普通进程</li>
</ul>
<p>实时进程的调度优先级比普通进程要高。优先级数值越低，优先级越高。</p>
<p>实时进程优先级范围：0-99</p>
<p>普通进程优先级范围：100-139</p>
<p><code>task_struct</code> 中有一个成员变量，叫 <strong>调度策略</strong> ：</p>
<pre><code class="c">unsigned int policy;
</code></pre>

<p>包括以下策略：</p>
<pre><code class="c">#define SCHED_NORMAL        0
#define SCHED_FIFO      1
#define SCHED_RR        2
#define SCHED_BATCH     3
#define SCHED_IDLE      5
#define SCHED_DEADLINE      6
</code></pre>

<p>其中，<code>SCHED_FIFO（先来先服务）</code> 、<code>SCHED_RR（时间片轮流调度）</code> 、<code>SCHED_DEADLINE（根据 deadline 选择调度）</code> 是实时进程调度策略，</p>
<p>剩余，<code>SCHED_NORMAL（普通进程）</code> 、<code>SCHED_BATCH（后台进程）</code>、<code>SCHED_IDLE（空闲进程）</code> 是普通进程调度策略。</p>
<p>通常最常用的调度算法是 普通进程使用的 <strong>完全公平调度算法：</strong></p>
<p>用球装进口袋的例子来理解，球少的袋子多放点球，这样经过几轮，虽不能保证所有口袋球完全一样，但也差不多公平。</p>
<p>这个算法的底层实现是通过 <strong>红黑树</strong> 来实现的。</p>
<p>红黑树的每个节点记录一个 vruntime，vruntime 是虚拟运行时间，也就是进程时钟 tick 数，用来记录每个进程占用 CPU 的时间滴答数，以此保证公平。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/c2/93/c2b86e79f19d811ce10774688fc0c093.jpeg" /></p>
<p>总结：</p>
<p>一个 CPU 上有一个队列，即 CFS（公平调度队列），这实现上是一颗红黑树，树的每一个节点都是一个 <code>sched_entity（调度实体）</code>，每个  <code>`sched_entity</code> 都属于一个 <code>task_struct</code>，<code>task_struct</code> 里有指针指向这个进程属于哪个调度类。在调度的时候，依次调用调度类的函数，从 CPU 的队列中取出下一个进程。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/10/af/10381dbafe0f78d80beb87560a9506af.jpeg" /></p>
<h2 id="16">16 调度（中）</h2>
<p>分为：主动调度和被动调度</p>
<p>进程上下文切换：</p>
<p>主要干两件事：一是切换进程空间，也即虚拟内存，二是切换寄存器和 CPU 上下文</p>
<p>主动调度的过程：</p>
<p>一个运行中的进程主动调用 <code>__schedule</code> 让出 CPU，在 <code>__schedule</code> 里会做两件事情，第一是选取下一个进程，第二是进行上下文切换，而上下文切换又分为用户进程空间切换和内核态的切换</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/9f/64/9f4433e82c78ed5cd4399b4b116a9064.png" /></p>
<h2 id="17">17 调度（下）</h2>
<p>抢占式调度：一个进程执行时间太长了，是时候切换到另一个进程了。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/93/7f/93588d71abd7f007397979f0ba7def7f.png" /></p>
<h2 id="18">18 进程的创建</h2>
<pre><code>首先调用 fork 系统调用

--&gt; sys_call_table --&gt; sys_fork
    --&gt; _do_fork
        --&gt; copy_process # 第一件大事
            --&gt; dup_task_struct
                --&gt; alloc_task_struct_node # 分配 task_struct
                --&gt; alloc_thread_stack_node # 创建内核栈
                --&gt; arch_dup_task_struct # 调用 memcpy 将task_struct 进行复制
                --&gt; setup_thread_stack # 设置 thread_info
            --&gt; copy_creds
                --&gt; prepare_creds # memcpy 复制一份父进程的 cred
                --&gt; 设置进程运行统计量
                --&gt; sched_fork # 设置调度相关的变量
                    --&gt; __sched_fork # 设置包括运行时间，进程状态，优先级，调度类
                --&gt; copy_files # 复制一个进程打开的文件信息
                    --&gt; dup_fd # 复制文件描述符
                    --&gt; file_fs # 复制一个进程的目录信息
                --&gt; copy_sighand # 初始化信号相关的变量
                --&gt; copy_mm # 复制内存空间，进程空间用 mm_struct 结构表示
        --&gt; wake_up_new_task # 第二件大事,试图唤醒创建的子进程
            --&gt; activate_task 
                --&gt; enqueue_task # 激活进程
            --&gt; enqueue_task_fair # 如果是 CFS 的调度类，执行相应调度类
</code></pre>

<p>以上第一阶段的过程如以下图示所示：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/9d/58/9d9c5779436da40cabf8e8599eb85558.jpeg" /></p>
<h2 id="19">19 线程的创建</h2>
<p>和进程一样，线程的创建是由用户态和内核态共同完成的。</p>
<p>它们都要依托于一个数据结构 <code>task_struct</code>，下面看看线程具体创建就的过程：</p>
<p>从用户调用 <code>pthread_create</code> 开始，</p>
<pre><code class="c">1、设置线程属性参数
2、pthread 结构用户态维护线程
3、创建线程栈(ALLOCATE_STACK)
    -
    -
4、进入内核 调用 create_thread
5、调用 __clone
    --&gt; sys_call
        --&gt; _do_fork # 和进程不同，这里主要是对相关的 结构 做引用计数 +1，而不是复制。
</code></pre>

<p>下图总结了进程和线程创建的区别：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/14/4b/14635b1613d04df9f217c3508ae8524b.jpeg" /></p>
<h2 id="20">20 内存管理（上）：规划进程内存空间布局</h2>
<p>操作系统管理的 三个方面：</p>
<ul>
<li>物理内存的管理：物理内存地址只有内存管理模块能够使用</li>
<li>虚拟内存的管理：每个进程看到的都是独立的，互不干扰的虚拟地址空间</li>
<li>虚拟地址和物理的地址的映射管理：虚拟地址和物理地址通过页表结构关联起来</li>
</ul>
<p>打印进程内存空间的布局的命令：</p>
<pre><code class="c">cat /proc/$pid/map
</code></pre>

<h2 id="21">21 内存管理（下）</h2>
<p>虚拟内存转到物理内存，需要用到两种机制：分段机制和分页机制。</p>
<p>分段机制：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/96/eb/9697ae17b9f561e78514890f9d58d4eb.jpg" /></p>
<p>大体思路是通过段基地址和段内偏移，将虚拟地址转换为物理地址。</p>
<p>分页机制：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/ab/40/abbcafe962d93fac976aa26b7fcb7440.jpg" /></p>
<p>通过页表目录项和页内偏移量，将虚拟地址转换为物理地址。</p>
<p>对于 64位，则页表目录更多，如下：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/42/0b/42eff3e7574ac8ce2501210e25cd2c0b.jpg" /></p>
<p>内存映射：将虚拟内存和物理内存映射起来，并且在内存紧张的时候可以换出到硬盘中。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/7d/91/7dd9039e4ad2f6433aa09c14ede92991.jpg" /></p>
<h2 id="22">22 进程空间管理</h2>
<p>进程的内存空间管理来自于一个结构：</p>
<pre><code class="c">struct mm_struct **mm
</code></pre>

<p>其中，一个成员变量:</p>
<pre><code class="c">unsigned long task_size
</code></pre>

<p>定义了用户空间和内核空间的大小分界线。</p>
<p>对于 32 位系统，最大能够寻址 2^32=4G，其中用户态虚拟地址空间是 3G，内核态是 1G。</p>
<p>对于 64 位系统，虚拟地址只使用了 48 位。用户空间和内核空间大小都是 128T。</p>
<p>如下：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/89/59/89723dc967b59f6f49419082f6ab7659.jpg" /></p>
<p>内存空间布局：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/7a/4c/7af58012466c7d006511a7e16143314c.jpeg" /></p>
<p>以上这些区域通过下面的结构描述：</p>
<pre><code class="c">struct vm_area_struct *mmap;        /* list of VMAs */
struct rb_root mm_rb;
</code></pre>

<p>64位的内核空间布局：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/7e/f6/7eaf620768c62ff53e5ea2b11b4940f6.jpg" /></p>
<p>整个过程，可以用下面的两幅图表示：</p>
<p>32位：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/28/e8/2861968d1907bc314b82c34c221aace8.jpeg" /></p>
<p>64位：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/2a/ce/2ad275ff8fdf6aafced4a7aeea4ca0ce.jpeg" /></p>
<h2 id="23">23 物理内存管理（上）</h2>
<p>物理内存的组织方式，有两种：</p>
<ul>
<li>SMP：对称多处理器</li>
<li>NUMA ：非一致内存访问</li>
</ul>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/8f/49/8f158f58dda94ec04b26200073e15449.jpeg" /></p>
<p>在 NUMA 结构中，把内存分成节点，把节点分成区域zone，区域又分为页，</p>
<p>页是组成物理内存的基本单位，页的数据结构是 <code>struct page</code>。</p>
<p>在Linux中，如果要分配比较大的内存，例如分配页级别的，可以使用伙伴系统。</p>
<p>几者之间的关系如下所示：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/3f/4f/3fa8123990e5ae2c86859f70a8351f4f.jpeg" /></p>
<h2 id="24">24 物理内存管理（下）</h2>
<p>物理内存分 NUMA 节点，分别进行管理</p>
<p>伙伴系统将多个连续的页面作为一个大的内存块分配给上层。</p>
<p>小内存的分配使用 slub 分配器。它会从伙伴系统中申请大内存块切分成小块，分配给其他系统。</p>
<p>内存页面的换入换出会使用一个内核线程 <code>kswapd</code>，它会循环检查内存的使用情况，当内存充足的时候，它什么也不会做，当内存吃紧了，它会检查是否应该换出一些内存页。</p>
<p>常用的一个内存换出算法是 LRU，也就是最近最少使用。</p>
<p>用下面这个图总结：伙伴系统和 Slub 分配器：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/52/54/527e5c861fd06c6eb61a761e4214ba54.jpeg" /></p>
<h2 id="25">25 用户态内存映射</h2>
<p>内存映射：</p>
<ul>
<li>物理内存和虚拟内存之间的映射</li>
<li>将文件中的内容映射到虚拟内存空间</li>
</ul>
<p>内存映射通过一个 系统调用 mmap 来完成，内存映射区在内存结构中的位置如下所示：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/f0/45/f0dcb83fcaa4f185a8e36c9d28f12345.jpg" /></p>
<p>当我们在申请内存时，如果申请的是小块内存，就用 brk，如果申请大块内存，就用 mmap。</p>
<p>mmap 依赖于页表项，页表由于一般都较大，所以只能放在内存中，这会导致访存的性能下降。</p>
<p>为了加快映射速度，引入 TLB 块表，TLB 存储在 Cache 中，存储的是页表项，可以直接通过虚拟地址找到物理地址。内存映射的时候，会首先查 TLB 表，块表中有映射关系，就直接转换为物理地址，如果没有，才会到内存中查询页表。</p>
<p>如果用户态访问没有映射的内存会引发缺页异常，分配物理页表、补齐页表。如果是 swap，则将 swap 文件读入，如果是文件映射，则将文件读入。</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/78/44/78d351d0105c8e5bf0e49c685a2c1a44.jpg" /></p>
<h2 id="26">26 内核态内存映射</h2>
<ul>
<li>vmalloc 和 kmap_atomic<ul>
<li>内核的虚拟地址空间 vmalloc 区域用于映射</li>
<li>kmap_atomic 临时映射<ul>
<li>32 位, 调用 set_pte 通过内核页表临时映射</li>
<li>64 位, 调用 page_address→lowmem_page_address 进行映射</li>
</ul>
</li>
</ul>
</li>
<li>内核态缺页异常<ul>
<li>kmap_atomic 直接创建页表进行映射</li>
<li>vmalloc 只分配内核虚拟地址, 访问时触发缺页中断, 调用 </li>
</ul>
</li>
</ul>
<p>物理内存管理：</p>
<p><img alt="" src="../images/phymem.png" /></p>
<p>用户态内存分配：</p>
<p><img alt="" src="../images/usermem.png" /></p>
<p>内核态内存分配：</p>
<p><img alt="" src="../images/kernelmem.png" /></p>
<p>内存分配体系总图：</p>
<p><img alt="img" src="https://static001.geekbang.org/resource/image/27/9a/274e22b3f5196a4c68bb6813fb643f9a.png" /></p>
<h2 id="27">27 文件系统</h2>
<p>文件系统的设计原则：</p>
<ul>
<li>严格的组织形式，以块为单位进行存储</li>
<li>要有索引区</li>
<li>应该有缓存层，存放经常被读写的文件</li>
<li>以文件夹的形式组织，方便管理和查询</li>
<li>linux 维护一套数据结构，保存哪些文件被哪些进程打开和使用</li>
</ul>
<p>文件系统相关的命令：</p>
<pre><code class="sh">fdisk -l
# 查看格式化和没有格式化的分区
</code></pre>

<pre><code class="sh">mkfs.ext4 /dev/vdc
# 对磁盘进行格式化，vdc会建立一个分区，格式化为 ext4 文件系统的格式。
</code></pre>

<pre><code class="sh">mount /dev/vdc1 / 根目录 / 用户 A 目录 / 目录 1 
# 格式化的分区需要挂到某个目录下面，才能作为普通的文件系统进行访问
</code></pre>

<pre><code class="sh">umount / 根目录 / 用户 A 目录 / 目录 1
# 卸载挂载
</code></pre>

<p>文件系统相关的系统调用：</p>
<p>文件相关：open, write, read, lseek, close</p>
<p>目录相关：opendir，readdir，closedir</p>
<p>文件属性由结构体 struct stat 来维护，由函数 stat，fstat，lstat来操作：</p>
<pre><code class="c">int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);


struct stat {
  dev_t     st_dev;         /* ID of device containing file */
  ino_t     st_ino;         /* Inode number */
  mode_t    st_mode;        /* File type and mode */
  nlink_t   st_nlink;       /* Number of hard links */
  uid_t     st_uid;         /* User ID of owner */
  gid_t     st_gid;         /* Group ID of owner */
  dev_t     st_rdev;        /* Device ID (if special file) */
  off_t     st_size;        /* Total size, in bytes */
  blksize_t st_blksize;     /* Block size for filesystem I/O */
  blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */
  struct timespec st_atim;  /* Time of last access */
  struct timespec st_mtim;  /* Time of last modification */
  struct timespec st_ctim;  /* Time of last status change */
};
</code></pre>

<p><img alt="" src="../images/stat.png" /></p>
<p>最后，用一幅图来总结之：</p>
<p><img alt="" src="../images/fsys.png" /></p>
<h2 id="28">28 硬盘文件系统</h2>
<p>硬盘结构：</p>
<p>https://static001.geekbang.org/resource/image/2e/d2/2ea68b40d928e6469233fcb4948c7cd2.jpg</p>
<p>Linux 主流文件系统格式：ext 系列，ext3, ext4</p>
<p>硬盘分成相同大小的块，一块的大小是扇区大小的整数倍，默认是 4K，格式化的时候，可以设定。</p>
<p>为了更好的管理文件，使用一个结构 inode 来维护，inode 保存一个文件的基本信息，提供索引机制，方便查找和管理。</p>
<pre><code class="c">struct ext4_inode {
    __le16  i_mode;     /* File mode */
    __le16  i_uid;      /* Low 16 bits of Owner Uid */
    __le32  i_size_lo;  /* Size in bytes */
    __le32  i_atime;    /* Access time */
    __le32  i_ctime;    /* Inode Change time */
    __le32  i_mtime;    /* Modification time */
    __le32  i_dtime;    /* Deletion Time */
    __le16  i_gid;      /* Low 16 bits of Group Id */
    __le16  i_links_count;  /* Links count */
    __le32  i_blocks_lo;    /* Blocks count */
    __le32  i_flags;    /* File flags */
......
    __le32  i_block[EXT4_N_BLOCKS];/* Pointers to blocks */
    __le32  i_generation;   /* File version (for NFS) */
    __le32  i_file_acl_lo;  /* File ACL */
    __le32  i_size_high;
......
};
</code></pre>

<p>其中，<code>i_block[]</code>  定义了一个文件被划分了多少块，每一块在哪里这些信息。</p>
<p><strong>文件在文件系统中使用 inode 来描述, 每个 inode 中都含有一些列的数据块</strong></p>
<ul>
<li>对于普通文件: 数据块中保存的是文件数据</li>
<li>对于文件夹: 数据块中保存的是子文件的文件项</li>
<li>为了加快文件夹中文件的搜索速度, Linux 通过索引模式, 可以使用文件名的散列快速定位到文件的位置</li>
</ul>
<p><strong>文件的组织</strong></p>
<ul>
<li>Linux 中将磁盘的块分成一个个的块组, 每个块组由一个块组的位图和对应的数据块描述, 最大可描述 128M 的空间</li>
<li>每个块组有其对应的块组描述符, 描述符之间形成一个链表</li>
<li>为了更好地管理块组, Linux 通过元块组来描述块组</li>
<li>一个元块组中由 64 个块组组成, 其中的块组描述符一共 64 项, 分别在 0, 1, 63 的位置的块组上备份三份</li>
<li>整个文件系统通过超级块来描述</li>
</ul>
<p><strong>软链接与硬链接</strong></p>
<ul>
<li>软链接: 在链接目标文件之前, 会创建自己的 inode 和数据块, 然后其数据块中的内容指向目标文件</li>
<li>可跨系统链接</li>
<li>硬链接: 即为一个文件创建了一个别名, 这个别名会指向真实文件的 inode 结构体</li>
<li>因为直接指向源文件结构体, 因此他无法跨文件系统进行链接</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
